#TODO wtf is going on here
let
  thingy = parent: extra: command:
    runCommand (parent.name + "-wrapper") ({
      preferLocalBuild = true;
      allowSubstitutes = false;

      buildInputs = [R] ++ recommendedPackages ++ packages;

      nativeBuildInputs = [makeWrapper];

      # Make the list of recommended R packages accessible to other packages such as rpy2
      passthru = { inherit recommendedPackages; };
      } // extra)
      command;
in {
  r = { runCommand, R, makeWrapper, recommendedPackages, packages }:
    thingy R {} ''
      mkdir -p $out/bin
      cd ${R}/bin
      for exe in *; do
        makeWrapper ${R}/bin/$exe $out/bin/$exe \
          --prefix "R_LIBS_SITE" ":" "$R_LIBS_SITE"
      done
      ''

  rstudio = { lib, runCommand, R, rstudio, makeWrapper, recommendedPackages, packages, qtbase }:
    thingy rstudio {
      # rWrapper points R to a specific set of packages by using a wrapper
      # (as in https://nixos.org/nixpkgs/manual/#r-packages) which sets
      # R_LIBS_SITE.  Ordinarily, it would be possible to make RStudio use
      # this same set of packages by simply overriding its version of R
      # with the wrapped one, however, RStudio internally overrides
      # R_LIBS_SITE.  The below works around this by turning R_LIBS_SITE
      # into an R file (fixLibsR) which achieves the same effect, then
      # uses R_PROFILE_USER to load this code at startup in RStudio.
      fixLibsR = "fix_libs.R";  
      } 
      ''
      mkdir $out
      ln -s ${rstudio}/share $out
      echo "# Autogenerated by wrapper-rstudio.nix from R_LIBS_SITE" > $out/$fixLibsR
      echo -n ".libPaths(c(.libPaths(), \"" >> $out/$fixLibsR
      echo -n $R_LIBS_SITE | sed -e 's/:/", "/g' >> $out/$fixLibsR
      echo -n "\"))" >> $out/$fixLibsR
      echo >> $out/$fixLibsR
      makeWrapper ${rstudio}/bin/rstudio $out/bin/rstudio \
        --set R_PROFILE_USER $out/$fixLibsR \
        --prefix QT_PLUGIN_PATH : ${qtbase}/lib/qt-${qtVersion}/plugins
      ''
  }
